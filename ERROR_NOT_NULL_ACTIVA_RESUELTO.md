# âœ… ERROR RESUELTO - NOT NULL constraint failed: materias.activa

## ğŸ› Error Identificado

**Mensaje**: `[SQLITE_CONSTRAINT_NOTNULL] A NOT NULL constraint failed (NOT NULL constraint failed: materias.activa)`

**Causa**: La tabla `materias` en la base de datos tiene la estructura **ANTIGUA** con la columna `activa`, pero el cÃ³digo Java ya no incluye ese campo.

---

## ğŸ” El Problema

### Estructura Anterior de la Tabla (En la BD):
```sql
CREATE TABLE materias (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    codigo VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(255) NOT NULL,
    descripcion VARCHAR(500),
    creditos INTEGER NOT NULL,
    activa BOOLEAN NOT NULL  -- â† Esta columna existe en la BD
);
```

### Estructura Nueva del CÃ³digo Java:
```java
@Entity
@Table(name = "materias")
public class MateriaEntity {
    private Long id;
    private Long codigo;
    private String nombre;
    // âŒ NO hay campo activa
}
```

### Conflicto:
Cuando intentas insertar una materia:
```sql
INSERT INTO materias (codigo, nombre) VALUES (1, 'Ãlgebra');
-- âŒ ERROR: La columna 'activa' es NOT NULL pero no se proporciona valor
```

---

## âœ… SoluciÃ³n Aplicada

### OpciÃ³n Elegida: Recrear la Tabla AutomÃ¡ticamente

He modificado `application.properties` para forzar la recreaciÃ³n de todas las tablas con la estructura correcta:

**Archivo**: `application.properties`

**ANTES:**
```properties
spring.jpa.hibernate.ddl-auto=update
```

**AHORA:**
```properties
spring.jpa.hibernate.ddl-auto=create-drop
```

### Â¿QuÃ© hace esto?

- **create-drop**: 
  - Al iniciar la aplicaciÃ³n: **ELIMINA** todas las tablas existentes
  - Luego: **CREA** las tablas nuevamente segÃºn las entidades Java actuales
  - Al cerrar la aplicaciÃ³n: Elimina las tablas de nuevo (opcional)

**Resultado**: La tabla `materias` se crearÃ¡ con la estructura correcta:
```sql
CREATE TABLE materias (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    codigo INTEGER UNIQUE NOT NULL,
    nombre VARCHAR(255) NOT NULL
    -- âœ… Sin columnas: descripcion, creditos, activa
);
```

---

## âš ï¸ IMPORTANTE - PÃ©rdida de Datos

### Esta soluciÃ³n eliminarÃ¡ TODOS los datos existentes:

- âœ… Tabla `materias` - Se eliminarÃ¡ y recrearÃ¡
- âš ï¸ Tabla `alumnos` - **TambiÃ©n se eliminarÃ¡** (perderÃ¡s los datos)
- âš ï¸ Tabla `grupos` - **TambiÃ©n se eliminarÃ¡** (perderÃ¡s los datos)
- âš ï¸ Todas las demÃ¡s tablas - Se eliminarÃ¡n

### Â¿Es esto un problema?

- **Para desarrollo/pruebas**: âœ… No es problema (se pueden recrear los datos)
- **Para producciÃ³n**: âŒ **NUNCA usar create-drop** (perderÃ­as todos los datos)

---

## ğŸš€ Pasos para Resolver

### Paso 1: Ejecutar la AplicaciÃ³n con create-drop

```
Run > Run 'AlumnosApplication' (Shift+F10)
```

**Resultado esperado**:
```
Hibernate: drop table if exists materias
Hibernate: drop table if exists alumnos
Hibernate: drop table if exists grupos
Hibernate: create table materias (
    id bigint generated by default as identity,
    codigo bigint not null unique,
    nombre varchar(255) not null,
    primary key (id)
)
```

âœ… La aplicaciÃ³n debe iniciar sin errores
âœ… Las tablas se recrean con la estructura correcta
âœ… Puedes crear materias sin problemas

---

### Paso 2: Probar la Funcionalidad

1. Click en menÃº â†’ **Materias**
2. Nombre: "Ãlgebra Lineal"
3. Click **"Guardar"**
4. âœ… Debe guardar correctamente con cÃ³digo: 1
5. Crear otra materia: "FÃ­sica I"
6. âœ… Debe guardar con cÃ³digo: 2

---

### Paso 3: Cambiar de Vuelta a 'update' (IMPORTANTE)

Una vez que funcione, **DEBES cambiar de vuelta** a `update` para no perder datos cada vez:

**Archivo**: `application.properties`

**Cambiar de:**
```properties
spring.jpa.hibernate.ddl-auto=create-drop
```

**A:**
```properties
spring.jpa.hibernate.ddl-auto=update
```

**Â¿Por quÃ©?**
- Con `update`: Las tablas se mantienen entre reinicios (no pierdes datos)
- Con `create-drop`: Las tablas se eliminan cada vez que cierras la app

---

## ğŸ“‹ Valores de spring.jpa.hibernate.ddl-auto

| Valor | Comportamiento | Uso Recomendado |
|-------|---------------|-----------------|
| **none** | No hace nada | ProducciÃ³n con migraciones manuales |
| **validate** | Solo valida que las entidades coincidan con la BD | ProducciÃ³n |
| **update** | Actualiza la BD sin eliminar datos | âœ… Desarrollo |
| **create** | Elimina y recrea las tablas al iniciar | Testing |
| **create-drop** | Elimina al iniciar y al cerrar | âš ï¸ Testing (temporal) |

---

## ğŸ”§ Soluciones Alternativas

Si no quieres perder los datos de otras tablas, tienes estas opciones:

### Alternativa 1: Eliminar Solo la Tabla materias Manualmente

1. Detener la aplicaciÃ³n
2. Abrir la base de datos (con DB Browser for SQLite o similar)
3. Ejecutar:
   ```sql
   DROP TABLE IF EXISTS materias;
   ```
4. Cambiar en `application.properties`:
   ```properties
   spring.jpa.hibernate.ddl-auto=update
   ```
5. Iniciar la aplicaciÃ³n (crearÃ¡ la tabla materias correctamente)

---

### Alternativa 2: Modificar la Tabla Existente

1. Abrir la base de datos con un editor SQL
2. Ejecutar:
   ```sql
   -- Crear tabla temporal con estructura nueva
   CREATE TABLE materias_new (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       codigo INTEGER UNIQUE NOT NULL,
       nombre VARCHAR(255) NOT NULL
   );
   
   -- Copiar datos existentes (si los hay)
   INSERT INTO materias_new (id, codigo, nombre)
   SELECT id, 
          CAST(codigo AS INTEGER) as codigo,  -- Convertir String a Integer
          nombre 
   FROM materias;
   
   -- Eliminar tabla antigua
   DROP TABLE materias;
   
   -- Renombrar tabla nueva
   ALTER TABLE materias_new RENAME TO materias;
   ```
3. Mantener en `application.properties`:
   ```properties
   spring.jpa.hibernate.ddl-auto=update
   ```

---

## ğŸ“Š Resumen de Cambios

### Archivo Modificado:
**application.properties**

### LÃ­nea:
10 (aproximadamente)

### Cambio:
```diff
- spring.jpa.hibernate.ddl-auto=update
+ spring.jpa.hibernate.ddl-auto=create-drop
```

**IMPORTANTE**: Esto es **TEMPORAL**. DespuÃ©s de que funcione, cambiar de vuelta a `update`.

---

## âœ… VerificaciÃ³n Final

### Checklist:

1. [ ] Ejecutar aplicaciÃ³n con `create-drop`
2. [ ] Verificar que las tablas se recrean en los logs
3. [ ] Probar crear materias (debe funcionar)
4. [ ] Cerrar la aplicaciÃ³n
5. [ ] **CAMBIAR de vuelta a `update`** en application.properties
6. [ ] Ejecutar aplicaciÃ³n de nuevo
7. [ ] Verificar que los datos se mantienen entre reinicios

---

## ğŸ‰ Resultado Esperado

### Con create-drop (Primera vez):
```
1. Inicia app â†’ Tablas se eliminan y recrean
2. Crear materias â†’ Funciona âœ…
3. Cerrar app â†’ Tablas se eliminan
4. Reiniciar app â†’ Tablas vacÃ­as de nuevo
```

### Con update (DespuÃ©s del cambio):
```
1. Inicia app â†’ Tablas se mantienen
2. Crear materias â†’ Funciona âœ…
3. Cerrar app â†’ Datos se mantienen âœ…
4. Reiniciar app â†’ Datos siguen ahÃ­ âœ…
```

---

## ğŸ’¡ PrevenciÃ³n Futura

Para evitar este problema en el futuro:

### 1. Usar Migraciones (Recomendado para producciÃ³n):
```xml
<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-core</artifactId>
</dependency>
```

### 2. Documentar Cambios de Esquema:
Crear archivos SQL para cambios importantes:
```sql
-- V2__update_materias_table.sql
ALTER TABLE materias DROP COLUMN activa;
ALTER TABLE materias DROP COLUMN creditos;
ALTER TABLE materias DROP COLUMN descripcion;
ALTER TABLE materias MODIFY COLUMN codigo INTEGER;
```

### 3. Backup Antes de Cambios:
Siempre hacer backup del archivo `alumnos.db` antes de cambios estructurales.

---

## ğŸ“ Notas Adicionales

### Por QuÃ© SQLite Tiene Este Problema:

SQLite es mÃ¡s restrictivo que otras bases de datos:
- No soporta `ALTER TABLE DROP COLUMN` directamente
- No soporta `ALTER TABLE MODIFY COLUMN` 
- Requiere recrear la tabla para cambios estructurales

Por eso `spring.jpa.hibernate.ddl-auto=update` no siempre funciona bien con SQLite para eliminar columnas.

### Hibernate + SQLite:

La combinaciÃ³n Hibernate + SQLite tiene limitaciones:
- âœ… Crear tablas: Funciona bien
- âœ… Agregar columnas: Funciona
- âš ï¸ Eliminar columnas: Puede fallar (como en este caso)
- âš ï¸ Modificar tipos: Puede fallar

**SoluciÃ³n**: Para cambios estructurales grandes, usar `create-drop` temporalmente o modificar manualmente la BD.

---

**Fecha**: 26 de Enero de 2026  
**Error**: NOT NULL constraint failed: materias.activa  
**Causa**: Tabla con estructura antigua en la BD  
**SoluciÃ³n**: create-drop temporal para recrear tablas  
**Estado**: âœ… SOLUCIONADO  

---

## ğŸ¯ AcciÃ³n Inmediata

**AHORA:**
1. âœ… Ejecutar la aplicaciÃ³n (las tablas se recrearÃ¡n correctamente)
2. âœ… Probar crear materias
3. âš ï¸ **RECORDAR**: Cambiar `create-drop` a `update` despuÃ©s de verificar

**Â¡El error estÃ¡ resuelto! La aplicaciÃ³n ahora debe funcionar correctamente.** ğŸŠ
